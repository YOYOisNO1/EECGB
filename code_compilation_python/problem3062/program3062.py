    # Здесь делаю через вложенные списки [[x1,y1],[x2,y2],[xi,yi]]. Строковые данные преобразую в целые числа и помещаю в списки.
    # Считаю сумму верхних половинок = upper . Затем нижних = lower. Проверяем четность обеих переменных
    # Когда ничего менять не надо, или всего одна кость - выводи соот. значение и все.
    # Иначе начинаем менять. Через for...in получаем кость из ряда ( т.е. список[xi,xi]), меняем местами и с помощью 
    # функции check_parity проверяем измения наших upper и lower, и их четность.В цикле есть счетчик(count)-кол-во изменений костей.
    # Если все хорошо - выводим 1, если нет, то берем след. кость и снова функцию... 
    # В конце, если мы не получили четность, и кол-во костей(n) равно значению счетчика(count)
    # т.е. n=count, то выводим -1
    
    Flag= True # для вечного цикла while. Он ниже
    upper = 0 #    сумма верхних половинок
    lower = 0 #    сумма нижних половинок
    Row_of_bones = []
    n = int(input())
    for i in range(n):												#Получив кол-во костей, последовательно заполняем список 
    	x = list(map(int, (input().split())))		#"Налету" превращаем в список с целыми числами
    	Row_of_bones.append(x)											#Собственно помещаем кость[xi,yi] в ряд []
    #print(Row_of_bones)
    #print(Row_of_bones[1][1])
    
def check_parity() -> bool:        #Функция, в которой я пересчитываю верхние и нижние суммы, а затем проверяю на четность.
    	upp,low =0,0
    	for i in Row_of_bones:
    		upp += i[0]
    		low += i[1]
    	if (upp % 2 == 0) and (low % 2 == 0):
    		#print("Апп и лов после смены кости = ", upp, " " ,low) # Можно отслеживать промежуточные результат
    		return True
    	else:
    		return False
    
    for i in Row_of_bones: # Считаю верхнию и нижнию сумму. В i помещается кость [xi,yi] из ряда
    	upper += i[0]
    	lower += i[1]
    	
    #print("Изначальные ап и лов = ",upper," ",lower) # Можно отслеживать промежуточные результат
    
    
    while(Flag):                                    # Бесконечный цикл, где мы проверяем на четность в первые раз и отсеиваем
    	if (upper % 2 == 0) and (lower % 2 == 0):   #простые случае, когда ничего делать не надо
    		print(0)
    		break
    	elif (n == 1):
    		print(-1)
    		break
    	else:
    		count = 0 # Счетчик действий
    		for i in Row_of_bones:
    			i[0],i[1] = i[1], i[0] # меняем местами значения элементов без буферной переменной, возможность питона
    			count+=1
    			if (check_parity()): # После одноразового перемещения первый кости проверяем на четность
    				print(1)     # Если все хорошо - выводим и выходим через break'и  
    				break
    		if count == n:      # Когда после смещения всех костей, ни к чему не пришли, то есть n == count
    			print(-1)       
    		break		
    # Хочу отметить, что основой алгоритм перещения кости - очень простой. Берем первую кость и просто переворачиваем.Затем вторую
    # и  так далее. И надеемся на чудо :) Тестовые данные обрабатывает правильно
    #Пробовал усложнить тестовые, и приходил к правильной работе программы
    #Входные:     3                4			5
    #           1  2             1  3		   1 3
    #           3  3             4  1		   4 1 
    #           6  4             5  6		   2 3
    #                            2  3		   6 5
    #										   3 4
    #Выходные:  -1               -1  